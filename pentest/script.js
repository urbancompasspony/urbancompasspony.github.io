// GLOBAL VARS
let updateInterval;

// UTILITY FUNCTIONS
function getTodayPattern() {
    const today = new Date();
    const day = String(today.getDate()).padStart(2, '0');
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const year = String(today.getFullYear()).slice(-2);
    return `${day}_${month}_${year}`;
}

function setMainStatus(icon, text, className = '') {
    const statusBanner = document.getElementById('main-status');
    const statusIcon = document.getElementById('status-icon');
    const statusText = document.getElementById('status-text');

    statusIcon.textContent = icon;
    statusText.textContent = text;

    // Remove existing status classes
    statusBanner.className = 'status-banner';
    if (className) {
        statusBanner.classList.add(className);
    }
}

function updateProgressBar(current, total) {
    const progressFill = document.getElementById('progress-fill');
    const percentage = total > 0 ? (current / total) * 100 : 0;
    progressFill.style.width = `${percentage}%`;
}

function updateCounters(testCount, vulnCount) {
    let completedTests = 0; // Declarar fora do if

    const totalTestsElement = document.getElementById('total-tests');
    if (totalTestsElement) {
        if (testCount > 0) {
            completedTests = Math.max(0, testCount - 1);
            totalTestsElement.textContent = completedTests;
        } else {
            fetch("/Todos_os_Resultados/")
                .then(r => r.text())
                .then(html => {
                    completedTests = countIPFiles(html);
                    totalTestsElement.textContent = completedTests;
                })
                .catch(() => {
                    totalTestsElement.textContent = 0;
                });
        }
    }

    // Update vulnerability badge
    const vulnBadge = document.getElementById('vuln-count');
    if (vulnBadge) {
        vulnBadge.textContent = vulnCount;

        if (vulnCount > 0) {
            vulnBadge.style.display = 'inline-block';
        } else {
            vulnBadge.style.display = 'none';
        }
    }

    console.log(`üìä Stats: ${completedTests} files completed, ${vulnCount} vulnerabilities`);
}

// IMPROVED IP FILE COUNTING FUNCTION - COUNT ALL IP FILES INCLUDING DUPLICATES
function countIPFiles(directoryHTML) {
    if (!directoryHTML) return 0;

    console.log('üîç Analisando conte√∫do do diret√≥rio para contar arquivos IP...');
    console.log('üìÑ HTML recebido:', directoryHTML.substring(0, 500) + '...');

    // Create a temporary div to parse HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = directoryHTML;

    // Get all links in the directory listing
    const links = tempDiv.querySelectorAll('a');
    const ipFiles = []; // Use array to count all files including duplicates

    console.log(`üîó Total de links encontrados: ${links.length}`);

    links.forEach((link, index) => {
        const fileName = link.textContent.trim();
        const href = link.getAttribute('href') || '';

        console.log(`üìÑ [${index}] Verificando: "${fileName}" (href: "${href}")`);

        // Skip parent directory links and empty entries
        if (fileName === '../' || fileName === '' || href === '../') {
            console.log(`‚¨ÜÔ∏è Ignorado: link para diret√≥rio pai`);
            return;
        }

        // Check if file/folder name starts with IP pattern (IP followed by numbers and dots)
        // Match patterns like: 172.20.0.102, 172.20.0.102_tcp_full, 172.20.0.102_udp_critical
        if (fileName.match(/^(\d{1,3}\.){3}\d{1,3}/)) {
            ipFiles.push(fileName);
            console.log(`‚úÖ Arquivo IP v√°lido encontrado: "${fileName}"`);
        } else if (fileName.match(/^(01_|02_|03_|04_)/)) {
            console.log(`üö´ Arquivo de controle ignorado: "${fileName}"`);
        } else {
            console.log(`‚ùå Arquivo ignorado (n√£o √© IP): "${fileName}"`);
        }
    });

    const count = ipFiles.length;
    console.log(`üìä Total de arquivos IP encontrados (incluindo duplicatas): ${count}`);
    console.log(`üìã Arquivos IP encontrados:`, ipFiles);

    return count;
}

// MAIN STATUS UPDATE FUNCTION
function updateStatus() {
    console.log('üîÑ Atualizando status...');

    // Try to get real-time status first
    fetch("/status.json")
        .then(response => {
            if (!response.ok) throw new Error('Status file not found');
            return response.json();
        })
        .then(status => {
            console.log('üìä Status real-time:', status);
            updateRealTimeStatus(status);
        })
        .catch(err => {
            console.log('‚ö†Ô∏è Status real-time indispon√≠vel, usando fallback...');
            updateFallbackStatus();
        });
}

function updateRealTimeStatus(status) {
    document.getElementById('total-tests').textContent = status.progress.current;
    // Update main status banner
    let statusClass = "info";
    let statusIcon = "üîç";
    let statusText = "";

    if (status.vulnerabilities > 0) {
        statusClass = "vulnerable";
        statusIcon = "üö®";
        statusText = `VULNERABILIDADES CR√çTICAS DETECTADAS: ${status.vulnerabilities}`;
    } else if (status.status === "running") {
        statusClass = "warning";
        statusIcon = "‚öôÔ∏è";
        statusText = "SCANNING EM ANDAMENTO...";
    } else if (status.status === "completed") {
        statusClass = "safe";
        statusIcon = "‚úÖ";
        statusText = "SCAN COMPLETO - NENHUMA VULNERABILIDADE CR√çTICA";
    } else {
        statusIcon = "üîç";
        statusText = "SISTEMA ATIVO - AGUARDANDO COMANDOS";
    }

    setMainStatus(statusIcon, statusText, statusClass);

    // Update progress information
    document.getElementById('scan-status').textContent =
        status.status === "running" ? "Em Execu√ß√£o" :
        status.status === "completed" ? "Conclu√≠do" : "Standby";

    document.getElementById('current-target').textContent =
        status.current_target || "N/A";

    document.getElementById('scan-progress').textContent =
        `${status.progress?.current || 0}/${status.progress?.total || 0}`;

    // Update progress bar
    updateProgressBar(
        status.progress?.current || 0,
        status.progress?.total || 0
    );

    document.getElementById('total-tests').textContent = status.progress?.current || 0;

    // Update counters
    updateCounters(
        status.progress?.current || 0,
        status.vulnerabilities || 0
    );
}

function updateFallbackStatus() {
    console.log('üîÑ Executando fallback status...');

    // Fallback: Get info from directory listings
    Promise.all([
        fetch("/Todos_os_Resultados/").then(r => r.text()).catch(() => ""),
        fetch("/Ataque_Bem-Sucedido/").then(r => r.text()).catch(() => "")
    ]).then(([resultsData, vulnData]) => {

        console.log('üìÇ Dados do diret√≥rio de resultados recebidos');

        // Count IP files using improved function
        const ipTestCount = countIPFiles(resultsData);

        // Count vulnerabilities
        const vulnMatches = vulnData.match(/RESUMO_/g) || [];
        const vulnCount = vulnMatches.length;

        console.log(`üìä Fallback stats: ${ipTestCount} arquivos IP testados, ${vulnCount} vulnerabilidades`);

        // Update main status
        let statusClass = "info";
        let statusIcon = "üîç";
        let statusText = "";

        if (vulnCount > 0) {
            statusClass = "vulnerable";
            statusIcon = "üö®";
            statusText = `${vulnCount} VULNERABILIDADES DETECTADAS`;
        } else if (ipTestCount > 0) {
            statusClass = "safe";
            statusIcon = "‚úÖ";
            statusText = `${ipTestCount} ARQUIVOS IP TESTADOS - SISTEMA SEGURO`;
        } else {
            statusIcon = "üîç";
            statusText = "SISTEMA ATIVO - NENHUM TESTE EXECUTADO";
        }

        setMainStatus(statusIcon, statusText, statusClass);

        // Update progress info (fallback mode)
        document.getElementById('scan-status').textContent = "Standby";
        document.getElementById('current-target').textContent = "N/A";
        document.getElementById('scan-progress').textContent = `${ipTestCount}/‚àû`;

        // Update counters
        updateCounters(ipTestCount, vulnCount);
        updateProgressBar(0, 1); // Unknown progress in fallback
    });
}

// INITIALIZATION
function init() {
    console.log('üöÄ Inicializando Project Pandora Interface...');

    // Initial status update
    updateStatus();

    // Set up auto-refresh (every 10 seconds)
    updateInterval = setInterval(updateStatus, 10000);

    console.log('‚úÖ Interface inicializada com sucesso!');
}

// ERROR HANDLING
window.addEventListener('error', function(e) {
    console.error('üö® JavaScript Error:', e.error);
});

// START WHEN DOM IS READY
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

// CLEANUP ON PAGE UNLOAD
window.addEventListener('beforeunload', function() {
    if (updateInterval) {
        clearInterval(updateInterval);
    }
});
