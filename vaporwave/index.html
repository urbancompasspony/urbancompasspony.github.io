<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Vaporwave 3D Room - Piscina Anos 80</title>
  <style>
    html, body { margin:0; width:100vw; height:100vh; overflow:hidden; background:#181a29; }
    canvas { display:block; }
    .credit {
      position: absolute;
      bottom: 10px;
      right: 20px;
      color: #fff;
      background: rgba(0,0,0,0.3);
      font-size: 12px;
      padding: 5px 10px;
      border-radius: 6px;
      z-index: 2;
      pointer-events: none;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div class="credit">Vaporwave Pool Demo - github copilot</div>
  <script type="module">
    import * as THREE from '/three.module.js';
    import { OrbitControls } from '/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x181a29);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 120);
    camera.position.set(0, 3.5, 9);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.6, 0);
    controls.enableDamping = true;
    controls.minDistance = 6;
    controls.maxDistance = 18;
    controls.maxPolarAngle = Math.PI / 2.05;
    controls.enablePan = false;

    function makeTileTexture(color1, color2, grout) {
      const s = 128;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = s;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = color1;
      ctx.fillRect(0, 0, s, s);
      ctx.strokeStyle = grout;
      ctx.lineWidth = 7;
      ctx.strokeRect(0, 0, s, s);
      ctx.strokeStyle = color2;
      ctx.lineWidth = 2;
      for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.moveTo(i * s / 4, 0);
        ctx.lineTo(i * s / 4, s);
        ctx.moveTo(0, i * s / 4);
        ctx.lineTo(s, i * s / 4);
        ctx.stroke();
      }
      return new THREE.CanvasTexture(canvas);
    }
    const tileTex = makeTileTexture('#3ef1f0', '#2f9adf', '#265a7b');
    tileTex.wrapS = tileTex.wrapT = THREE.RepeatWrapping;
    tileTex.repeat.set(5, 5);

    const tileMat = new THREE.MeshStandardMaterial({
      map: tileTex,
      roughness: 0.23,
      metalness: 0.35,
    });

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), tileMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

    const ceiling = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 10),
      new THREE.MeshStandardMaterial({ color: 0xfad5ff, metalness: 0.12, roughness: 0.95 })
    );
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = 5.2;
    scene.add(ceiling);

    function wall(w, h, rx, ry, rz, tx, ty, tz) {
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), tileMat);
      mesh.position.set(tx, ty, tz);
      mesh.rotation.set(rx, ry, rz);
      scene.add(mesh);
    }
    wall(10, 5.2, 0, 0, 0, 0, 2.6, -5);
    wall(10, 5.2, 0, Math.PI / 2, 0, -5, 2.6, 0);
    wall(10, 5.2, 0, -Math.PI / 2, 0, 5, 2.6, 0);

    function makeGlassWindow(x, y, z, color) {
      const glassMat = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.08,
        metalness: 0.25,
        opacity: 0.68,
        transparent: true,
        emissive: color,
        emissiveIntensity: 0.48,
      });
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.2, 0.12, 8, 8, 1), glassMat);
      mesh.position.set(x, y, z);
      scene.add(mesh);
    }
    makeGlassWindow(-2.4, 3.0, -4.98, 0x25edff);
    makeGlassWindow(2.7, 2.3, -4.98, 0xf65fff);

    function makePool() {
      const shape = new THREE.Shape();
      shape.absarc(-1.7, 0.9, 1.1, Math.PI * 1.08, Math.PI * 1.8, false);
      shape.quadraticCurveTo(-1.5, -0.7, 0.1, -1.5);
      shape.quadraticCurveTo(2.4, -0.7, 2.0, 0.8);
      shape.absarc(0.15, 1.05, 2.0, 0, Math.PI, true);
      const extrudeSettings = { depth: 0.35, bevelEnabled: true, bevelThickness: 0.09, bevelSize: 0.04, bevelSegments: 2, steps: 1 };
      const pool = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, extrudeSettings), tileMat);
      pool.position.set(0, 0.01, 0);
      scene.add(pool);
      const water = new THREE.Mesh(
        new THREE.ShapeGeometry(shape),
        new THREE.MeshPhysicalMaterial({
          color: 0x73d7f0,
          metalness: 0.55,
          roughness: 0.14,
          transparent: true,
          opacity: 0.72,
          transmission: 0.93,
          clearcoat: 0.8,
          clearcoatRoughness: 0.08,
        })
      );
      water.position.set(0, 0.18, 0);
      water.rotation.x = -Math.PI / 2;
      scene.add(water);
    }
    makePool();

    function makePalm(x, z, y = 0.15, scale = 1.08, rot = 0) {
      const palm = new THREE.Group();
      const trunkGeom = new THREE.CylinderGeometry(0.08 * scale, 0.13 * scale, 2.6 * scale, 8);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6d4d30, roughness: 0.5, metalness: 0.15 });
      const trunk = new THREE.Mesh(trunkGeom, trunkMat);
      trunk.position.y = 1.25 * scale + y;
      palm.add(trunk);
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x9ae378, roughness: 0.25, metalness: 0.35, side: THREE.DoubleSide });
      for (let i = 0; i < 7; i++) {
        const leafGeom = new THREE.PlaneGeometry(0.7 * scale, 0.18 * scale, 1, 8);
        const pos = leafGeom.attributes.position;
        for (let v = 0; v < pos.count; v++) {
          const y = pos.getY(v);
          const curve = Math.sin((y / 0.18 / 8.0) * Math.PI) * 0.28 * scale;
          pos.setZ(v, curve);
        }
        const leaf = new THREE.Mesh(leafGeom, leafMat);
        leaf.position.y = 2.55 * scale;
        leaf.rotation.x = Math.PI / 2.45;
        leaf.rotation.z = Math.PI * 2 * i / 7 + rot;
        leaf.position.x = Math.cos(leaf.rotation.z) * 0.33 * scale;
        leaf.position.z = Math.sin(leaf.rotation.z) * 0.33 * scale;
        palm.add(leaf);
      }
      palm.position.set(x, 0.0, z);
      palm.scale.setScalar(scale);
      scene.add(palm);
    }
    makePalm(-2.3, 1.3, 0, 1.1, 0.12);
    makePalm(2.3, -1.8, 0, 0.93, 0.08);
    makePalm(1.9, 2.5, 0, 0.74, -0.3);

    scene.add(new THREE.AmbientLight(0x6ef9fc, 0.16));

    const blueLight = new THREE.PointLight(0x44eaff, 1.1, 16);
    blueLight.position.set(-2.5, 3.6, -2.3);
    scene.add(blueLight);

    const pinkLight = new THREE.PointLight(0xff54d8, 1.1, 13);
    pinkLight.position.set(2.7, 2.0, -3.5);
    scene.add(pinkLight);

    function animate() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
